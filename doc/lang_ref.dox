/*! \page LangRef ThreadScript language reference
 *
 * \section Canonical_syntax Canonical syntax
 *
 * The rules in the grammar are composed from leaf rules defined in class
 * threadscript::parser_ascii::rules::factory (abbreviated as \c rf), combined
 * by operators defined in namespace threadscript::parser and in classes
 * threadscript::parser::rules::dyn and threadscript::parser::rule_base:
 * \arg \link threadscript::parser::operator-() -R \endlink -- 0 to
 * 1 occurrence
 * \arg \link threadscript::parser::operator-() +R \endlink -- at least
 * 1 occurrence
 * \arg \link threadscript::parser::operator-() *R \endlink -- at least
 * 0 occurrences
 * \arg \link threadscript::parser::operator-() R1>>R2 \endlink --
 * concatenation
 * \arg \link threadscript::parser::operator-()  R1|R2 \endlink --
 * alternative
 * \arg \link threadscript::parser::operator-() !R \endlink -- disables
 * following alternatives
 * \arg \link threadscript::parser::rules::dyn::operator>>=() D>>=R \endlink
 * -- sets a child of a dynamic rule
 * \arg \link threadscript::parser::rule_base::operator[]() R[H] \endlink --
 * sets a handler for the rule (the parameter is a function)
 * \arg \link threadscript::parser::rule_base::operator[]() R["E"sv] \endlink --
 * sets an error message for the rule (the parameter is a std::string_view)
 * \arg \link threadscript::parser::rule_base::operator()() R("T"sv) \endlink --
 * sets a tracing name for the rule (the parameter is a std::string_view)
 *
 * Each rule is defined by a single occurrence of macro #RULE, which specifies
 * a rule name and definition (body). Definition os some rules, e.g., \c
 * node_fun and \c _params, is more complex in order to get better error
 * messages.
 *
 * The grammar, with \c script as the top-level rule:
 *
 * \snippet syntax_canon.cpp Grammar
 *
 * \section Script_execution Script execution
 *
 * \section Builtin_commands Built-in commands
 */
