/*! \page LangRef ThreadScript language reference
 *
 * \tableofcontents
 *
 * \section Canonical_syntax Canonical syntax
 *
 * The rules in the grammar are composed from leaf rules defined in class
 * threadscript::parser_ascii::rules::factory (abbreviated as \c rf), combined
 * by operators defined in namespace threadscript::parser and in classes
 * threadscript::parser::rules::dyn and threadscript::parser::rule_base:
 * \arg \link threadscript::parser::operator-() -R \endlink -- 0 to
 * 1 occurrence
 * \arg \link threadscript::parser::operator-() +R \endlink -- at least
 * 1 occurrence
 * \arg \link threadscript::parser::operator-() *R \endlink -- at least
 * 0 occurrences
 * \arg \link threadscript::parser::operator-() R1>>R2 \endlink --
 * concatenation
 * \arg \link threadscript::parser::operator-()  R1|R2 \endlink --
 * alternative
 * \arg \link threadscript::parser::operator-() !R \endlink -- disables
 * following alternatives
 * \arg \link threadscript::parser::rules::dyn::operator>>=() D>>=R \endlink
 * -- sets a child of a dynamic rule
 * \arg \link threadscript::parser::rule_base::operator[]() R[H] \endlink --
 * sets a handler for the rule (the parameter is a function)
 * \arg \link threadscript::parser::rule_base::operator[]() R["E"sv] \endlink --
 * sets an error message for the rule (the parameter is a std::string_view)
 * \arg \link threadscript::parser::rule_base::operator()() R("T"sv) \endlink --
 * sets a tracing name for the rule (the parameter is a std::string_view)
 *
 * Each rule is defined by a single occurrence of macro #RULE, which specifies
 * a rule name and definition (body). Definition os some rules, e.g., \c
 * node_fun and \c _params, is more complex in order to get better error
 * messages.
 *
 * The grammar, with \c script as the top-level rule:
 *
 * \snippet syntax_canon.cpp Grammar
 *
 * \section Script_values Values
 *
 * All values are accessed via \a references. A reference can point to a value
 * of any type, or contain a special value \c null (not pointing to any value).
 * Copying a reference, e.g., assigning to a variable or setting an element of
 * a \c vector or a \c hash does not copy the value. That is, the original and
 * the new reference point to the same value, which can be read or modified via
 * any of them.
 *
 * ThreadScript core languange provides the following scalar data types:
 * \arg \c bool -- It contains a Boolean value \c false or \c true. It is
 * represented by C++ type \c bool.
 * \arg \c int -- A signed integer of implementation-defined size, using two's
 * complement representation. Overflow in an arithmetic operation throws an
 * exception. It is represented by C++ type
 * threadscript::config::value_int_type.
 * \arg \c unsigned -- An unsigned integer of implementation-defined size. It
 * uses modulo arithmetic, therefore it never overflows. It is represented by
 * C++ type threadscript::config::value_unsigned.
 * \arg \c string -- A string of characters of C++ type \c char. It is
 * represented by C++ type std::string. Unlike the C++ type, its storage not
 * only grows, but also shrinks according to its content.
 *
 * ThreadScript core languange provides the following container data types:
 * \arg \c vector -- A vector of arbitrary variable size. Each element can
 * contain a value of any type, including \c null. It is represented by C++
 * type std::vector. Unlike the C++ type, its storage not only grows, but also
 * shrinks according to its content.
 * \arg \c hash -- An unordered has map of string keys to values of arbitrary
 * types, including \c null. It is represented by C++ type std::unordered_map.
 * Unlike the C++ type, its storage not only grows, but also shrinks according
 * to its content.
 * 
 * Any modifiable value of a type from the core language is thread-local, that
 * is, it is owned by a single thread and cannot be accessed by other threads.
 * In order to make a value shareable among threads, it must be marked as
 * \a thread-safe (sometimes denoted as \a mt-safe), which also makes the value
 * read-only.
 *
 * \section Script_execution Script execution
 *
 * A script in the ThreadScript language is executed according to the internal
 * code representation obtained by parsing source code using a parser for
 * a selected syntax variant. The internal representation directly corresponds
 * to the structure of source in the canonical syntax. It is a tree of nodes,
 * with values in leaves and calls of named commands or functions in named
 * (internal) nodes. Child nodes of an internal node are interpreted as command
 * or function arguments. The script is executed by evaluating the root of the
 * tree, which yields a single value or terminates by an exception.
 *
 * We use words \e "command" and \e "function" almost interchangeably, because
 * they are both represented by named nodes in the code tree and implemented in
 * the same way. In the canonical syntax, commands and functions are
 * syntactically indistinguishable. Whether something behaves as a command or
 * a function depends on its internal implementation and is described in its
 * documentation. Generally, a \e function first evaluates all its parameters
 * and then computes a result. Imagine, e.g., a function computing a sum of its
 * numeric parameters. On the other hand, a \e command uses its own logic to
 * dynamically decide if and when each parameter is evaluated. An example is
 * a conditional (\c if) command. It first evaluates its first argument (the
 * condition). If it yields true, the second argument (the "then" branch) is
 * evaluated and the third argument (the "else" branch) is not evaluated. If
 * the condition yileds false, the second argument is skipped and the third
 * argument is evaluated.
 * 
 * \section Builtin_commands Built-in commands and functions
 *
 * Built-in commands and functions are defined as classes in namespace
 * threadscript::predef. A name \c FUN used in ThreadScript source code
 * corresponds to a declaration \c f_FUN in the namespace.
 *
 * \section Integer_arithmetic Integer arithmetic
 *
 * Semantics of arithmetic operations with integers is based on rules of C++20.
 * Unsigned arithmetic (with arguments of type \c unsigned) is performed
 * <em>modulo 2<sup>N</sup></em>, where \e N is the number of bits in
 * threadscript::config::value_unsigned_type. Overflow of signed arithmetic
 * operations (with arguments of type \c int) throws exception
 * threadscript::exception::op_overflow.
 *
 * Due to different rules of signed and unsigned arithmentics, signed and
 * unsigned values may not be mixed in a single expression. Otherwise,
 * exception threadscript::exception::value_type is thrown. */
