#pragma once

/*! \file
 * \brief Implementation of predefined built-in symbols. 
 */

#include "threadscript/symbol_table.hpp"
#include "threadscript/vm_data.hpp"

namespace threadscript {

//! Namespace for implementation of predefined built-in (C++ native) symbols
/*! This namespace contains predefined function implementation in classes
 * derived from threadscript::basic_value_native_fun. The class names have
 * prefix \c f_ in order to not collide with C++ keywords. It also contains
 * definitions of any predefined variables.
 *
 * Declarations in this namespace should be kept in the lexicographical order.
 * \test in file test_predef.cpp */
namespace predef {

//! Implementation of function \c print.
/*! It writes all its arguments atomically to the standard output, which can be
 * redirected to any \c std::ostream by basic_state::std_out or
 * basic_virtual_machine::std_out. Output generated by a single call of \c
 * print is not interleaved by other output to the same stream. It returns \c
 * null. */
template <impl::allocator A>
class f_print final: public basic_value_native_fun<A> {
    using basic_value_native_fun<A>::basic_value_native_fun;
protected:
    typename basic_value<A>::value_ptr eval(basic_state<A>& thread,
        const basic_symbol_table<A>& lookup,
        const std::vector<std::reference_wrapper<basic_symbol_table<A>>>& sym,
        const basic_code_node<A>& node, std::string_view fun_name) override;
};

//! Implementation of command \c seq.
/*! It evaluates all its arguments sequentially. This is essentially equivalent
 * to a block of commands in other programming languages. It returns \c null. */
template <impl::allocator A>
class f_seq final: public basic_value_native_fun<A> {
    using basic_value_native_fun<A>::basic_value_native_fun;
protected:
    typename basic_value<A>::value_ptr eval(basic_state<A>& thread,
        const basic_symbol_table<A>& lookup,
        const std::vector<std::reference_wrapper<basic_symbol_table<A>>>& sym,
        const basic_code_node<A>& node, std::string_view fun_name) override;
};

} // namespace predef

//! Creates a new symbol table containing predefined built-in symbols.
/*! \tparam A an allocator type
 * \param[in] alloc the allocator used for creating the symbol table
 * \return a newly creating symbol table containing predefined built-in C++
 * native symbols defined in namespace threadscript::predef. */
template <impl::allocator A>
std::shared_ptr<basic_symbol_table<A>> predef_symbols(const A& alloc);

//! Adds default predefined built-in symbols to a symbol table.
/*! It adds built-in C++ native symbols defined in namespace
 * threadscript::predef into \a sym. It is usually used to initialize a symbol
 * table that will be set as the global shared symbol table
 * basic_virtual_machine::sh_vars. The function does nothing if \a sym is \c
 * nullptr.
 * \tparam A an allocator type
 * \param[in] sym a symbol table
 * \param[in] replace if \c false, any existing symbol with a name equal to
 * a name to be added is left unchanged; if \c true, any such symbol is
 * replaced by the default value.
 * \return \a sym */
template <impl::allocator A> std::shared_ptr<basic_symbol_table<A>>
add_predef_symbols(std::shared_ptr<basic_symbol_table<A>> sym,
                    bool replace = false);

} // namespace threadscript
